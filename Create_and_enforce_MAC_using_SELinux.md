Selinux in centOS or redhat is enabled by default
In ubuntu we use appArmor
Systemctl status apparmor.service
install selinux-basics and auditd

Check if SELinux is enabled
sestatus

ls -Z

The question marks appear instead of proper security labels
Run:
selinux-activate

ls -a /
To see a hidden file called .autorelabel

Try to see labels in processes.
ps auxZ

example
/usr/sbin/sshd

ls -Z /usr/sbin/sshd

You will see that this file has the label sshd_exec_t to user "system_u"

Reboot the system to get the labels instead of the question marks

getenforce => To see enforcing mode 

=====================================================================================
In the world of Linux security,  **auditd** and **audit2allow** are two tools that work together to beef up your system's defenses. Here's a breakdown of what each one does:

**auditd: The System's Watchdog**

* Imagine a vigilant guard keeping a watchful eye on everything happening in your system. That's essentially what **auditd** does. 
It's a daemon (background service) that acts as the Linux auditing system's core.
* Its job is to track and record security-related events in centralized audit logs.
 These events can be anything from someone trying to access a file to programs being executed or privilege changes.
* By keeping a detailed log, **auditd** provides a valuable audit trail. 
If something suspicious happens, you can examine these logs to see what went down and potentially identify intruders or troubleshoot issues.
* You can configure **auditd** through the `/etc/audit/auditd.conf` file. 
This file lets you specify what events to record, the amount of detail to capture, and where to store the logs.

**audit2allow: Turning Denied Requests into Permissions**

* Now, let's say **auditd** catches someone trying to access a file but doesn't have permission. 
This results in a permission denial, which gets logged.
* This is where **audit2allow** comes in. 
It's an analysis tool that specifically looks at these permission denial events in the audit logs, particularly those related to SELinux (Security Enhanced Linux).
* **audit2allow** doesn't magically grant access. Instead, it helps you create security rules (SELinux policies) that would allow these legitimate access requests. 
* Think of it as a translator. It analyzes the denial reason and suggests corresponding rules that would permit the action if it's truly necessary.
* **audit2allow** generates a policy file containing these suggested rules. However, it's crucial to review these rules carefully before implementing them.  The suggested rules might be broader than necessary and could introduce vulnerabilities. 

**Working Together: A Security Powerhouse**

1. **auditd** diligently watches and records security events, including permission denials.
2. You examine the audit logs and identify a legitimate access request that was denied (e.g., a program needing a file to function).
3. You use **audit2allow** to analyze the specific denial and generate potential authorization rules.
4. You meticulously review the suggested rules to ensure they only grant the necessary access and don't create security holes.
5. If the rules are good to go, you can use them to update your SELinux policy, allowing the previously denied access.

**Important Considerations**

* **Don't blindly trust audit2allow:** While it helps automate rule creation, the suggested rules might be too permissive.
 Always review and refine them before implementation.
* **auditd isn't just for SELinux:** It can record events for other security mechanisms as well. audit2allow just focuses on SELinux specifically.

**In essence, auditd and audit2allow form a powerful team. They allow you to monitor system activity, identify security concerns, and fine-tune your security policies with more precision.** Just remember to use audit2allow with caution and keep a watchful eye on the rules it generates.
=================================================================================================================================
sudo audit2why --all => To get audit logs

We can use another command to tell SELinux to enable everything we witnessed up to this point

audit2allow --all -M mymodule => We can rename the module as we wish
--all => aotion tells a tool to inspect all logged events and -M option tells to generate a so-called module or policy package.

Copy the command in the output
*.pp is "policy package"
*.te "type enforcement"

So if we explore the mymodule file.te file we get an idea about the SELinux policy generated by the audit to allow.
In the real scenario, we'd have to scan this file thoroughly and explore everything this would allow on the system before actually deploying rules to SELinux.
Check the SElinux documentation for more information

For example we try to understand a line in this policy
sshd_t domain : is the name of this type , and it should be doing a certain thing

"allow sshd_t var_log_t:file {append create getattr ioctl open}" Should be able to do certain actions on files labeled var_log_t type
In this case, they should be allowed to create, open, edit and perform all of these different actions on this file.
Also, SSH daemon has to log its activities in the /var/log/auth.log.
And if we have take a look at the labels for that specific file where it should be logging to (ls -Z /var/log/auth.log), well notice the var_log_t type label applied to it.
In the policy generated by audit to allow it told SELinux to allow processes under the sshd_t domain to create and to write to files labeled with var_log_t type.

Other example:

If someone took control of say an Nginx web server process, they won't be able to read and modify system files.
They would only be able to touch only files that have specific labels targeted for an http daemon.
